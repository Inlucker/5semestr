\chapter{Индивидуальное задание}
\label{cha:research}

\section{Исходная программа}

Вернемся к изучению программы, выданной по индивидуальному заданию. Ее содержание отличиется тем, что вместо уменьшения счетчика цикла, увеличивается адрес блока значений для суммирования. 

Более наглядно порядок выполнения стадий конвейера процессора можно посмотреть с использованием диаграммы трассы работы программы.

Ниже, на рисунке \ref{img:pipeline_1} приведена трасса работы программы.

\imgsc{H}{0.40}{pipeline_1}{Диаграмма, соответствующая этапам выборки и диспетчеризации}

Примечание --- цифрой $1$ обозначен этап выборки (адрес интересующей команды равен $0x80000018$), данной команде на данном этапе присваивается $pc\_id = 6$; цифрой 2 обозначен этап диспетчеризации; цифрой 3 обозначен этап дешифрования и планирования (декодирование выполняется не сразу, так как сигнал $decode\_advance = 0$); цифрой 4 обозначен этап выполения (этап выполняется не сразу из-за конфликта [сигнал $rs2\_conflict = 1$]); во время такта, на котором остановлен желтый селектор, уже виден результат выполнения ($unit\_wb[0]/new\_request = 1$; $unit\_wb[0].done = 1$; $unit\_wb[0].id = 6$)

Ниже, на рисунке \ref{img:task_051} приведена временная диаграмма, поясняющая этапы обработки команды $add x31, x31, x2 \#!$.

\imgsc{H}{0.50}{task_051}{Диаграмма, поясняющая обработку команды $add x31, x31, x2 \#!$}

\section{Оптимизация программы}

Из рассмотрения выше представленной трассы видно, что выполнение программы до окончания последней команды $addi x1, x1, 16$ заняло 45 тактов (1-45). Из них, в течение 18 тактов(
7, 8, 11, 12, 15, 16, 19, 20, 25, 26, 29, 30, 33, 34, 37, 38, 41, 42) не происходило планирование на выполнение новых команд, то есть, 40\% времени было потрачено не эффективно из-за ошибок предсказания ветвлений и конфликтов на конвейере. Имеется возможность существенно сократить время выполнения путем перестановки команд для ликвидации конфликтов. 

Ниже в листинге \ref{code:source_2} приведена оптимизированная программа. Доступ к памяти выполняется за 3 такта, поэтому можно переставить команды так, чтобы регистры, в которые загружаются элементы массива блоком обращения к памяти, были бы освобождены за один такт до того, как с ними начнет работать АЛУ. Таким образом, можно сделать предположение, что для уменьшения времени работы программы загрузку всех необходимых данных в регистры из физической памяти следует выполнять до выполнения каких-либо арифметических операций.

\begin{lstlisting}[label=code:source_2, caption=Листинг оптимизированной программы]
		.section .text
_start:
        la x1, _x
        addi x20, x1, elem_sz*len #Адрес последнего элемента
lp:
        lw x2, 0(x1)
        lw x3, 4(x1)
        lw x4, 8(x1)
        lw x5, 12(x1)
        add x31, x31, x2
        add x31, x31, x3
        add x31, x31, x4
        add x31, x31, x5
        addi x1, x1, elem_sz*enroll
        bne x1, x20, lp
        addi x31, x31, 1
lp2: j lp2
        .section .data
        ...
\end{lstlisting}

\begin{lstlisting}[label=code:source_2, caption=Деассемблированный листинг оптимизированной  программы]
Disassembly of section .text:

80000000 <_start>:
80000000:       00000097                auipc   x1,0x0
80000004:       03c08093                addi    x1,x1,60 # 8000003c <_x>
80000008:       02008a13                addi    x20,x1,32

8000000c <lp>:
8000000c:       0000a103                lw      x2,0(x1)
80000010:       0040a183                lw      x3,4(x1)
80000014:       0080a203                lw      x4,8(x1)
80000018:       00c0a283                lw      x5,12(x1)
8000001c:       002f8fb3                add     x31,x31,x2
80000020:       003f8fb3                add     x31,x31,x3
80000024:       004f8fb3                add     x31,x31,x4
80000028:       005f8fb3                add     x31,x31,x5
8000002c:       01008093                addi    x1,x1,16
80000030:       fd409ee3                bne     x1,x20,8000000c <lp>
80000034:       001f8f93                addi    x31,x31,1

80000038 <lp2>:
80000038:       0000006f                jal     x0,80000038 <lp2>
\end{lstlisting}

Ниже, на рисунке \ref{img:pipeline_2} приведена трасса работы оптимизированной программы.

\imgsc{H}{0.50}{pipeline_2}{Трасса работы оптимизированной программы}

\section{Вывод}

Выполнение участка кода до последней команды $addi x1, x1, 16$ заняло 29 тактов, что в 1.55 раза меньше времени выполнения неоптимизированной программы. Из них только втечение 2 тактов не происходило планирование на выполнение новых команд (около 7\%). Из этого можно заключить, что предложенная оптимизация оправдана.