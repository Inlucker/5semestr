\newpage

\section{Ответы на контрольные вопросы}

\textbf{1. Назовите причины расслоения оперативной памяти}

Расслоение памяти позволяет повысить пропускную способность оперативной памяти (ОП) за счет компоновки ОП из нескольких банков. При таком построении, процедуры обращений к нескольким банкам памяти можно совместить.

\textbf{2. Как в современных процессорах реализована аппаратная предвыборка?}

Если говорить о суперскалярных процессорах, то суть предвыборки заключается в том, чтобы как можно лучше загрузить вычислительный конвейер: при каждой возможности производится считывание команд из памяти, опережающее ход вычислений. Команды после выборки помещаются в быстродействующем буфере предвыборки. Буфер, например, может быть организован по принципу очереди, тогда команды в него поступают в порядке их выполнения в программе. Высокое быстродействие буфера и наличие в нем значительного количества команд позволяет одновременно загружать все конвейеры процессора.

Также можно привести другой пример аппаратной предвыборки: уменьшение времени получения физического адреса страницы ОП при загрузке его в TLB. Суть предвыборки заключается в загрузке физического адреса не одной страницы, а сразу нескольких (8 или 16) за одно обращение к памяти [это возможно за счет расслоения памяти].

\textbf{3. Какая информация храниться в TLB?}

Если рассматривать машину со страничной организацией виртуальной памяти, то физические адреса начала страниц в физической памяти (фреймов).

\textbf{4. Какой тип ассоциативной памяти используется в кэш-памяти второго уровня современных ЭВМ и почему?}

Частично-ассоциативный, так как сочетает  достоинства  прямого  и  полностью  ассоциативного  способов отображения: экономия памяти тэгов (по сравнению с полностью ассоциативным кэшем) и уменьшение количества попаданий в один и тот же набор линеек кэша (по сравнению с прямым отображением).

\textbf{5. Приведите пример программной предвыборки}

Ниже в листинге \ref{code:code_5} приведена часть программы из 3 эксперимента.

\begin{lstlisting}[label=code:code_5, caption=Пример программной предвыборки]
int *p = get_array(arr_size);	// Get huge array from enternal world
int tmp;
for (int a = 0; a < arr_size; a += SIZEOF_PAGE)
	tmp = *(int *) (int(p) + a);

for (int a = 0; a < arr_size; a += 1)
{
	int elem = *(int *) (int(p) + a);
	...							// Array processing
}
\end{lstlisting}